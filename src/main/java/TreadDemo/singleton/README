该工程演示满足高并发的常用设计模式
    1 高并发下的单例设计模式
        饿汉式
            分析：会不会有并发问题，分别从三个角度来讨论，1 原子性 2 有序性 3 可见性
             *  private static Singletion1 singletion = new Singletion1(); 这段程序发生在类的初始化当中，
             *  类的初始化函数不存在并发问题，所以没有并发问题
        懒汉式
            分析：会不会有并发问题，分别从三个角度来讨论，1 原子性 2 有序性 3 可见性
             *  我们先从第一个原子性进行分析
             *  因为其不是原子性的，当线程1判断 singletion = null ,然后进去，这时线程2也判断singletion = null
             *  也进去，这时就不是单例的了。
             *
            满足高并发的懒汉式
                *  解决办法：
                *  使用synchronized
            满足高并发并且效率较高的懒汉式
                分析：会不会有并发问题，分别从三个角度来讨论，1 原子性 2 有序性 3 可见性
                 *  上面这种的话这个函数就是串行化的了，效率不是很高，我们进行改写
                 *  demo01这种方式我们来分析一下，第一 原子性 没有问题 第二 有序性 但是有序性就有问题了
                 *  如果是先构建的Singletion3，在构建的成员变量name passworld的话，就会有空指针异常
                 *
                 *  解决办法 ： 在加上volatile关键字
        结合类加载特点的懒汉式
            分析：会不会有并发问题，分别从三个角度来讨论，1 原子性 2 有序性 3 可见性
             *  我们前面说过 类的初始化是线程安全的

        枚举方式
            利用了跟静态类一样的特性
